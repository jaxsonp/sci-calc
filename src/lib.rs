use std::fmt::{self, format};
use lalrpop_util::lalrpop_mod;

pub mod context;
use context::*;

mod ast;
use ast::*;

lalrpop_mod!(grammar);

pub fn calculate(input_str: &str, ctx: &mut Context) -> Result<f64, CalcError> {

	// invoking grammar parser generated by lalrpop
	let parser = grammar::targetParser::new();
	let (tree, assignment) = parser.parse(input_str).unwrap();
	println!("Tree: {tree}");

	// evaluating ast
	let res = evaluate_ast(*tree, ctx);

	// handling assignment
	if assignment.is_some() && res.is_ok() {
		let _assign_var = assignment.unwrap();
	}

	return res;
}

fn evaluate_ast(root: Expr, ctx: &Context) -> Result<f64, CalcError> {
	match root {
		Expr::Num(n) => {
			Ok(n)
		}
		Expr::Op(left_e, op, right_e) => {
			// evaluation inner expressions
			let lhs = match evaluate_ast(*left_e, ctx) {
				Ok(n) => n,
				Err(e) => { return Err(e) },
			};
			let rhs = match evaluate_ast(*right_e, ctx) {
				Ok(n) => n,
				Err(e) => { return Err(e) },
			};
			// performing operation
			let res = match op {
				Operation::Add => { lhs + rhs }
				Operation::Sub => { lhs - rhs }
				Operation::Mul => { lhs * rhs }
				Operation::Div => { lhs / rhs }
				Operation::FloorDiv => { f64::floor(lhs / rhs) }
				Operation::Mod => { lhs % rhs }
				Operation::Exp => { lhs.powf(rhs) }
			};
			Ok(res)
		}
		Expr::Func(name, arg_list) => {
			let mut args: Vec<f64> = Vec::new();
			for arg in arg_list {
				let val = match evaluate_ast(*arg, ctx) {
					Ok(n) => n,
					Err(e) => { return Err(e) },
				};
				args.push(val);
			}
			if let Some(res) = ctx.try_function(&name, args) {
				return res;
			}
			return Err(CalcError {
				error_type: CalcErrorType::UndefinedIdentifier,
				msg: format!("Unknown function \"{name}()\""),
			})
		}
		Expr::Fac(e) => {
			// TODO fix :(
			let mut n = match evaluate_ast(*e, ctx) {
				Ok(n) => n,
				Err(e) => { return Err(e) },
			};
			let mut res = 1f64;
			while n > 0.0 {
				res *= n;
				n -= 1.0;
			}
			return Ok(res);
		}
		Expr::Err(e) => {
			// parser produced an error
			return Err(e);
		}
	}
}


#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CalcErrorType {
	SyntaxError,
	ParserError,
	UndefinedIdentifier,
	AssignmentError,
	ArgumentError,
	CalculationError,
}
impl fmt::Display for CalcErrorType {
	fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
		write!(formatter, "{}", match *self {
			Self::SyntaxError => { "Syntax error" },
			Self::ParserError => { "Parser error" },
			Self::UndefinedIdentifier => { "Undefined identifier" },
			Self::AssignmentError => { "Assignment error" },
			Self::ArgumentError => { "Argument error" },
			Self::CalculationError => { "Calculation error" },
		})
	}
}

#[derive(Debug, Clone, PartialEq)]
pub struct CalcError {
	error_type: CalcErrorType,
	msg: String,
}
impl fmt::Display for CalcError {
	fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
		write!(formatter, "{}: {}\n", self.error_type, self.msg)
	}
}
